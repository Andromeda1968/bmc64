diff --git a/libgloss/circle/fstat.c b/libgloss/circle/fstat.c
index 4e18d42..9727a64 100644
--- a/libgloss/circle/fstat.c
+++ b/libgloss/circle/fstat.c
@@ -12,13 +12,4 @@
 extern int errno;
 #include "warning.h"
 
-int
-_DEFUN (_fstat, (fildes, st),
-        int          fildes _AND
-        struct stat *st)
-{
-  errno = ENOSYS;
-  return -1;
-}
-
-stub_warning(_fstat)
+// Moved to io.cpp
diff --git a/libgloss/circle/getpid.c b/libgloss/circle/getpid.c
index 0ea1923..d5cf197 100644
--- a/libgloss/circle/getpid.c
+++ b/libgloss/circle/getpid.c
@@ -14,8 +14,8 @@ int
 _DEFUN (_getpid, (),
         _NOARGS)
 {
-  errno = ENOSYS;
-  return -1;
+  // For BMC64 : Any number will do here.
+  return 100;
 }
 
 stub_warning(_getpid)
diff --git a/libgloss/circle/io.cpp b/libgloss/circle/io.cpp
index 23720b6..44b3f36 100644
--- a/libgloss/circle/io.cpp
+++ b/libgloss/circle/io.cpp
@@ -1,385 +1,593 @@
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/dirent.h>
-#include <fcntl.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <string.h>
+#include <sys/dirent.h>
+#include <sys/stat.h>
+#include <sys/types.h>
 #undef errno
 extern int errno;
 #include "warning.h"
 
-#include <circle/fs/fat/fatfs.h>
-#include <circle/input/console.h>
-#include <circle/string.h>
 #include "circle_glue.h"
 #include <assert.h>
 
-struct _CIRCLE_DIR {
-        _CIRCLE_DIR() :
-                mFirstRead(0), mOpen(0)
-        {
-                mEntry.d_ino = 0;
-                mEntry.d_name[0] = 0;
-        }
-
-        TFindCurrentEntry mCurrentEntry;
-        struct dirent mEntry;
-        unsigned int mFirstRead : 1;
-        unsigned int mOpen : 1;
+#include <malloc.h>
+#include <sys/unistd.h>
+
+#include <ff.h>
+
+// This is a replacement io.cpp specifically for BMC64.
+// This implementation will sometimes load the entire file
+// into memory to provide faster seek operations, improving
+// performance on slow SD cards.  Since any file the emulator
+// attempts to load is relatively small (<200k), this works out
+// just fine for our needs. Obviously, this would not be a
+// viable solution for most other circumstances.  It also
+// works around an issue with circle/fatfs integration that
+// was causing memory corruption.
+//
+// When a file is opened for READ ONLY, fatfs is used to open
+// the file.  As long as the client never seeks, the file will
+// not be loaded into ram and fatfs still backs the data.  As
+// soon as seek is called, the file will be loaded into ram and
+// from then on, ram backs the data.  NOTE the fatfs file remains
+// open even after the file is loaded into ram in this case. If
+// the client never calls seek, the data will be read from fatfs.
+//
+// When a file is opened for WRITE ONLY, fatfs is used to create
+// the file. However, all write operations write to ram and only
+// when the file is finally closed will the data be dumped to
+// the fat fs filesystem.  The fatfs file remains open during
+// the entire time between open/close.  Seek is technically
+// supported in this case but attempting to seek past the
+// current file size is not.  Call to fstat on a file in WRTE_ONLY
+// mode will not work as expected.
+//
+// When a file is opened for READ_WRITE, fat fs is used to
+// immediately load the contents of the existing file into ram.
+// The input fat fs file is immediatly closed in this case.
+// Writes & seeks use the ram copy. Only when the file is closed
+// will the fatfs system be used to create a new file from the ram.
+// Again, seeking past the file's current length is not supported.
+
+#define MAX_OPEN_FILES 10
+#define MAX_OPEN_DIRS 10
+#define READ_BUF_SIZE 1024
+
+static const char *pattern = "*";
+
+struct CircleFile {
+  FIL file;
+  int in_use;
+  char fname[256];
+
+  char readBuf[READ_BUF_SIZE];
+  char *contents;
+  int allocated;
+  unsigned size;
+  unsigned position;
+  int mode;
+};
 
+struct CircleDir {
+  CircleDir() {
+    mEntry.d_ino = 0;
+    mEntry.d_name[0] = 0;
+    dir.pat = pattern;
+    in_use = 0;
+  }
+
+  DIR dir;
+  int in_use;
+  struct dirent mEntry;
 };
 
-namespace
-{
-    struct CircleFile
-    {
-    	CircleFile() : mCGlueIO(nullptr) {}
-    	CGlueIO *mCGlueIO;
-    };
+CircleFile fileTab[MAX_OPEN_FILES];
+CircleDir dirTab[MAX_OPEN_DIRS];
+
+void CGlueStdioInit() {
+  // Initialize stdio, stderr and stdin
+  fileTab[0].in_use = 1;
+  fileTab[1].in_use = 1;
+  fileTab[2].in_use = 1;
+}
+
+void CGlueInitConsole(CConsole &rConsole) {
+  CGlueStdioInit();
+}
+void CGlueStdioInit(CFATFileSystem &rFATFileSystem, CConsole &rConsole) {
+  CGlueStdioInit();
+}
+void CGlueStdioInit(CFATFileSystem &rFATFileSystem) {
+  CGlueStdioInit();
+}
+void CGlueStdioInit(CConsole &rConsole) {
+  CGlueStdioInit();
+}
+
+static int FindFreeFileSlot(void) {
+  int slotNr = -1;
 
-    constexpr unsigned int MAX_OPEN_FILES = 20;
-    constexpr unsigned int MAX_OPEN_DIRS = 20;
+  for (const CircleFile &slot : fileTab) {
+    if (slot.in_use == 0) {
+      slotNr = &slot - fileTab;
+      break;
+    }
+  }
 
-    CFATFileSystem *circle_fat_fs = nullptr;
+  return slotNr;
+}
 
-    CircleFile fileTab[MAX_OPEN_FILES];
-    _CIRCLE_DIR dirTab[MAX_OPEN_DIRS];
+static char *strdup2(const char *s) {
+  char *d = (char *)malloc(strlen(s) + 1);
+  if (d == nullptr)
+    return nullptr;
+  strcpy(d, s);
+  return d;
+}
 
-    int FindFreeFileSlot(void)
-    {
-    	int slotNr = -1;
+static void reverse(char *x, int begin, int end) {
+  char c;
 
-    	for (auto const& slot: fileTab)
-    	{
-    		if (slot.mCGlueIO == nullptr)
-    		{
-    			slotNr = &slot - fileTab;
-    			break;
-    		}
-    	}
+  if (begin >= end)
+    return;
 
-    	return slotNr;
-    }
+  c = *(x + begin);
+  *(x + begin) = *(x + end);
+  *(x + end) = c;
 
-    int FindFreeDirSlot(void)
-    {
-    	int slotNr = -1;
+  reverse(x, ++begin, --end);
+}
 
-    	for (auto const& slot: dirTab)
-    	{
-    		if (!slot.mOpen)
-    		{
-    			slotNr = &slot - dirTab;
-    			break;
-    		}
-    	}
+static void itoa2(int i, char *dst) {
+  int q = 0;
+  int j;
+  do {
+    j = i % 10;
+    dst[q] = '0' + j;
+    q++;
+    i = i / 10;
+  } while (i > 0);
+  dst[q] = '\0';
+
+  reverse(dst, 0, strlen(dst) - 1);
+}
 
-    	return slotNr;
-    }
+// BCM64 : For routing stdout/stderr to serial via circle
+extern "C" {
+extern ssize_t circle_serial_write(int fd, const void *buf, size_t count);
+}
+static void logm(const char *msg) { circle_serial_write(1, msg, strlen(msg)); }
+static void logi(int i) { char nn[16]; itoa2(i,nn); circle_serial_write(1, nn, strlen(nn)); }
 
-    void
-    CGlueInitFileSystem (CFATFileSystem& rFATFileSystem)
-    {
-            // Must only be called once
-            assert (!circle_fat_fs);
+static int FindFreeDirSlot(void) {
+  int slotNr = -1;
 
-            circle_fat_fs = &rFATFileSystem;
+  for (const CircleDir &slot : dirTab) {
+    if (!slot.in_use) {
+      slotNr = &slot - dirTab;
+      break;
     }
+  }
 
-    void
-    CGlueInitConsole (CConsole& rConsole)
-    {
-            CircleFile &stdin = fileTab[0];
-            CircleFile &stdout = fileTab[1];
-            CircleFile &stderr = fileTab[2];
-
-            // Must only be called once and not be called after a file has already been opened
-            assert (!stdin.mCGlueIO);
-            assert (!stdout.mCGlueIO);
-            assert (!stderr.mCGlueIO);
-
-            stdin.mCGlueIO = new CGlueConsole (rConsole, CGlueConsole::ConsoleModeRead);
-            stdout.mCGlueIO = new CGlueConsole (rConsole, CGlueConsole::ConsoleModeWrite);
-            stderr.mCGlueIO = new CGlueConsole (rConsole, CGlueConsole::ConsoleModeWrite);
-    }
+  return slotNr;
 }
 
-void CGlueStdioInit(CFATFileSystem& rFATFileSystem, CConsole& rConsole)
-{
-        CGlueInitConsole (rConsole);
-        CGlueInitFileSystem (rFATFileSystem);
+static CircleDir *FindCircleDirFromDIR(DIR *dir) {
+  for (CircleDir &slot : dirTab) {
+    if (slot.in_use && dir == &slot.dir) {
+      return &slot;
+    }
+  }
+  return nullptr;
 }
 
-void CGlueStdioInit (CFATFileSystem& rFATFileSystem)
-{
-        CGlueInitFileSystem (rFATFileSystem);
+static void slurp_file(CircleFile &file) {
+  if (file.contents == nullptr) {
+    // Read the entire contents of the file into our
+    // memory buffer.
+    file.size = 0;
+    unsigned total = 0;
+    if (f_lseek(&file.file, 0) != FR_OK) {
+       return;
+    }
+    while (true) {
+      unsigned int num_read;
+      if (f_read(&file.file, file.readBuf, READ_BUF_SIZE, &num_read) != FR_OK) {
+        break;
+      }
+
+      if (num_read == 0) {
+        break;
+      }
+      
+      if (file.contents == nullptr) {
+        file.allocated = READ_BUF_SIZE;
+        file.contents = (char *)malloc(file.allocated);
+      } else if (file.allocated < total + num_read) {
+        file.allocated *= 2;
+        file.contents = (char *)realloc(file.contents, file.allocated);
+      }
+
+      memcpy(file.contents + total, file.readBuf, num_read);
+      total += num_read;
+      file.size = total;
+    }
+  }
 }
 
-void CGlueStdioInit (CConsole& rConsole)
-{
-        CGlueInitConsole (rConsole);
+
+
+extern "C" int _DEFUN(_open, (file, flags, mode),
+                      char *file _AND int flags _AND int mode) {
+  // There's no 'current' dir. Everything is off the root.
+  if (file[0] == '.') file++;
+
+  int const masked_flags = flags & 7;
+  if (masked_flags != O_RDONLY && masked_flags != O_WRONLY &&
+      masked_flags != O_RDWR) {
+    errno = ENOSYS;
+    return -1;
+  }
+
+  int slot = FindFreeFileSlot();
+
+  if (slot != -1) {
+    CircleFile &newFile = fileTab[slot];
+
+    int result;
+    if (masked_flags == O_RDONLY) {
+      result = f_open(&newFile.file, file, FA_READ);
+    } else if (masked_flags == O_WRONLY) {
+      result = f_open(&newFile.file, file, FA_WRITE | FA_CREATE_ALWAYS);
+    } else {
+      assert(masked_flags == O_RDWR);
+      // Note: We open read only because this will be slurped and changed
+      // in memory.
+      result = f_open(&newFile.file, file, FA_READ);
+    }
+
+    if (result != FR_OK) {
+      errno = EACCES;
+      return -1;
+    }
+
+    newFile.contents = nullptr;
+    newFile.position = 0;
+    newFile.size = 0;
+    newFile.allocated = 0;
+    newFile.mode = masked_flags;
+    strcpy(newFile.fname, file);
+
+    // When file is opened O_RDWR, slurp it into memory.
+    if (masked_flags == O_RDWR) {
+       slurp_file(newFile);
+       if (newFile.size == 0 || f_close(&newFile.file) != FR_OK) {
+          slot = -1;
+          errno = ENFILE;
+       }
+    }
+
+    newFile.in_use = 1;
+  } else {
+    errno = ENFILE;
+  }
+
+  return slot;
 }
 
-extern "C"
-int
-_DEFUN (_open, (file, flags, mode),
-		char *file _AND
-		int flags _AND
-		int mode)
-{
-	int slot = -1;
-
-	// Only supported modes are read and write. The mask is
-	// determined from the newlib header.
-	int const masked_flags = flags & 7;
-	if (masked_flags != O_RDONLY && masked_flags != O_WRONLY)
-	{
-		errno = ENOSYS;
-	}
-	else
-	{
-		slot = FindFreeFileSlot();
-
-		if (slot != -1)
-		{
-			CircleFile& newFile = fileTab[slot];
-			unsigned handle;
-			if (masked_flags == O_RDONLY)
-			{
-				handle = circle_fat_fs->FileOpen (file);
-			}
-			else
-			{
-				assert(masked_flags ==  O_WRONLY);
-				handle = circle_fat_fs->FileCreate (file);
-			}
-			if (handle != 0)
-			{
-				newFile.mCGlueIO = new CGlueIoFatFs(*circle_fat_fs, handle);
-			}
-			else
-			{
-				slot = -1;
-				errno = EACCES;
-			}
-		}
-		else
-		{
-			errno = ENFILE;
-		}
-	}
-
-	return slot;
+extern "C" int _DEFUN(_close, (fildes), int fildes) {
+  if (fildes < 0 || static_cast<unsigned int>(fildes) >= MAX_OPEN_FILES) {
+    errno = EBADF;
+    return -1;
+  }
+
+  CircleFile &file = fileTab[fildes];
+  if (!file.in_use) {
+    errno = EBADF;
+    return -1;
+  }
+
+  if (file.contents) {
+     if (file.mode == O_RDWR) {
+        // Assert FIL is not used
+        if (f_open(&file.file, file.fname,
+                      FA_WRITE | FA_CREATE_ALWAYS) != FR_OK) {
+           // We won't be able to flush in memory changes back to disk.
+        }
+     }
+
+     if (file.mode == O_RDWR || file.mode == O_WRONLY) {
+        // Dump contents of memory buffer to actual file.
+        unsigned int num_written;
+        if (f_write(&file.file, file.contents,
+                      file.size, &num_written) != FR_OK) {
+           // Can't write new file or modified file contents back to disk.
+        }
+     }
+  }
+
+  file.allocated = 0;
+  file.size = 0;
+  file.mode = 0;
+  file.in_use = 0;
+  file.fname[0] = '\0';
+
+  if (file.contents) {
+    free(file.contents);
+    file.contents = nullptr;
+  } 
+  
+  if (f_close(&file.file) != FR_OK) {
+    errno = EIO;
+    return -1;
+  }
+
+  return 0;
 }
 
-extern "C"
-int
-_DEFUN (_close, (fildes),
-        int fildes)
-{
-	if (fildes < 0 || static_cast<unsigned int>(fildes) >= MAX_OPEN_FILES)
-	{
-		errno = EBADF;
-		return -1;
-	}
-
-	CircleFile& file = fileTab[fildes];
-	if (file.mCGlueIO == nullptr)
-	{
-		errno = EBADF;
-		return -1;
-	}
-
-	unsigned const circle_close_result = file.mCGlueIO->Close();
-
-	delete file.mCGlueIO;
-	file.mCGlueIO = nullptr;
-
-	if (circle_close_result == 0)
-	{
-		errno = EIO;
-		return -1;
-	}
-
-	return 0;
+extern "C" int _DEFUN(_read, (fildes, ptr, len),
+                      int fildes _AND char *ptr _AND int len) {
+  if (fildes < 0 || static_cast<unsigned int>(fildes) >= MAX_OPEN_FILES) {
+    errno = EBADF;
+    return -1;
+  }
+
+  CircleFile &file = fileTab[fildes];
+  if (!file.in_use) {
+    errno = EBADF;
+    return -1;
+  }
+
+  unsigned int num_read;
+  if (file.contents == nullptr) {
+     // Assert file.FIL has been opened
+     // else EBADF -1
+
+     // Read data from the file
+     if (f_read(&file.file, ptr, len, &num_read) != FR_OK) {
+       errno = EIO;
+       return -1;
+     }
+
+     file.position += num_read;
+     return static_cast<int>(num_read);
+  } else {
+     // Read data from our internal buffer
+     unsigned int max = len;
+     unsigned int remain = file.size - file.position;
+
+     if (max > remain) {
+        max = remain;
+     }
+
+     if (max > 0) {
+        memcpy(ptr, file.contents + file.position, max);
+        file.position += max;
+     }
+     return static_cast<int>(max);
+  }
 }
 
-extern "C"
-int
-_DEFUN (_read, (fildes, ptr, len),
-        int   fildes  _AND
-        char *ptr   _AND
-        int   len)
-{
-	if (fildes < 0 || static_cast<unsigned int>(fildes) >= MAX_OPEN_FILES)
-	{
-		errno = EBADF;
-		return -1;
-	}
-
-	CircleFile& file = fileTab[fildes];
-	if (file.mCGlueIO == nullptr)
-	{
-		errno = EBADF;
-		return -1;
-	}
-
-	unsigned const read_result = file.mCGlueIO->Read(ptr, static_cast<unsigned>(len));
-
-	if (read_result == CGlueIO::GeneralFailure)
-	{
-		errno = EIO;
-		return -1;
-	}
-
-	return static_cast<int>(read_result);
+extern "C" int _DEFUN(_write, (fildes, ptr, len),
+                      int fildes _AND char *ptr _AND int len) {
+  if (fildes < 0 || static_cast<unsigned int>(fildes) >= MAX_OPEN_FILES) {
+    errno = EBADF;
+    return -1;
+  }
+
+  if (fildes == 1 || fildes == 2) {
+    return circle_serial_write(fildes, ptr, len);
+  }
+
+  CircleFile &file = fileTab[fildes];
+  if (!file.in_use) {
+    errno = EBADF;
+    return -1;
+  }
+
+  // Nothing allocated yet? Allocate now.
+  if (file.contents == nullptr) {
+     file.allocated = READ_BUF_SIZE;
+     file.contents = (char *) malloc(file.allocated);
+  }
+
+  // Make sure we always have enough room allocated for the
+  // next write.
+  while (file.position + len >= file.allocated) {
+     file.allocated *= 2;
+     file.contents = (char *)realloc(file.contents, file.allocated);
+  }
+
+  // Do the write.
+  memcpy(file.contents + file.position, ptr, len);
+  file.position += len;
+  if (file.position > file.size) {
+     file.size = file.position;
+  }
+
+  return len;
 }
 
-extern "C"
-int
-_DEFUN (_write, (fildes, ptr, len),
-        int   fildes  _AND
-        char *ptr   _AND
-        int   len)
-{
-	if (fildes < 0 || static_cast<unsigned int>(fildes) >= MAX_OPEN_FILES)
-	{
-		errno = EBADF;
-		return -1;
-	}
-
-	CircleFile& file = fileTab[fildes];
-	if (file.mCGlueIO == nullptr)
-	{
-		errno = EBADF;
-		return -1;
-	}
-
-	unsigned const write_result = file.mCGlueIO->Write(ptr, static_cast<unsigned>(len));
-
-	if (write_result == CGlueIO::GeneralFailure)
-	{
-		errno = EIO;
-		return -1;
-	}
-
-	return static_cast<int>(write_result);
+extern "C" DIR *opendir(const char *name) {
+  char* n2 = strdup2(name);
+  char* f2 = n2;
+  // There is no 'current' dir. Everything is off the root.
+  // So if the client asks for it, switch to '.'
+  if (strlen(n2) == 1 && n2[0] == '.') { n2[0] = '/'; }
+  if (strlen(n2) > 2 && n2[0] == '.' && n2[1] == '/') n2++;
+
+  int const slotNum = FindFreeDirSlot();
+  if (slotNum == -1) {
+    errno = ENFILE;
+    free(f2);
+    return 0;
+  }
+
+  CircleDir &slot = dirTab[slotNum];
+  if (f_opendir(&slot.dir, n2) != FR_OK) {
+    errno = ENFILE;
+    free(f2);
+    return 0;
+  }
+
+  slot.in_use = 1;
+  free(f2);
+  return &slot.dir;
 }
 
-extern "C"
-DIR *
-opendir (const char *name)
-{
-        assert (circle_fat_fs);
-
-        /* For now only the single root directory and the current directory are supported */
-        if (strcmp(name, "/") != 0 && strcmp(name, ".") != 0)
-        {
-                errno = ENOENT;
-                return 0;
-        }
+static struct dirent *do_readdir(CircleDir *dir, struct dirent *de) {
 
-        int const slotNum = FindFreeDirSlot ();
-        if (slotNum == -1)
-        {
-                errno = ENFILE;
-                return 0;
-        }
+  assert(dir->in_use);
 
-        auto &slot = dirTab[slotNum];
+  FILINFO fno;
+  struct dirent *result = nullptr;
 
-        slot.mOpen = 1;
-        slot.mFirstRead = 1;
+  FRESULT res = f_findnext(&dir->dir, &fno);
+  if (res == FR_OK && fno.fname[0] != 0) {
+    strcpy(de->d_name, fno.fname);
+    de->d_ino = 0;
+    de->d_type = 0;
+    if (fno.fattrib & AM_DIR) {
+      de->d_type |= DT_DIR;
+    } else {
+      de->d_type |= DT_REG;
+    }
+    result = de;
+  }
 
-        return &slot;
+  return result;
 }
 
-static struct dirent *
-do_readdir (DIR *dir, struct dirent *de)
-{
-        TDirentry Direntry;
-        bool haveEntry;
-        if (dir->mFirstRead)
-        {
-                haveEntry = circle_fat_fs->RootFindFirst (&Direntry, &dir->mCurrentEntry);
-                dir->mFirstRead = 0;
-        }
-        else
-        {
-                haveEntry = circle_fat_fs->RootFindNext (&Direntry, &dir->mCurrentEntry);
-        }
+extern "C" struct dirent *readdir(DIR *dir) {
+  struct dirent *result;
 
-        struct dirent *result;
-        if (haveEntry)
-        {
-                memcpy (de->d_name, Direntry.chTitle, sizeof(de->d_name));
-                de->d_ino = 0; // TODO: how to determine an inode number in Circle?
-                result = de;
-        }
-        else
-        {
-                // end of directory does not change errno
-                result = nullptr;
-        }
+  CircleDir *c_dir = FindCircleDirFromDIR(dir);
+  if (c_dir == nullptr) {
+    errno = EBADF;
+    return nullptr;
+  }
 
-        return result;
+  return do_readdir(c_dir, &c_dir->mEntry);
 }
 
-extern "C" struct dirent *
-readdir (DIR *dir)
-{
-        struct dirent *result;
+extern "C" int readdir_r(DIR *__restrict dir, dirent *__restrict de,
+                         dirent **__restrict ode) {
+  int result;
+  CircleDir *c_dir = FindCircleDirFromDIR(dir);
 
-        if (dir->mOpen)
-        {
-                result = do_readdir (dir, &dir->mEntry);
-        }
-        else
-        {
-                errno = EBADF;
-                result = nullptr;
-        }
+  if (c_dir == nullptr) {
+    *ode = nullptr;
+    result = EBADF;
+  } else {
+    *ode = do_readdir(c_dir, de);
+    result = 0;
+  }
 
-        return result;
+  return result;
 }
 
-extern "C" int
-readdir_r (DIR *__restrict dir, dirent *__restrict de, dirent **__restrict ode)
-{
-        int result;
+extern "C" void rewinddir(DIR *dir) { f_rewinddir(dir); }
 
-        if (dir->mOpen)
-        {
-                *ode = do_readdir (dir, de);
-                result = 0;
-        }
-        else
-        {
-                *ode = nullptr;
-                result = EBADF;
-        }
+extern "C" int closedir(DIR *dir) {
+  CircleDir *c_dir = FindCircleDirFromDIR(dir);
+  if (c_dir == nullptr) {
+    errno = EBADF;
+    return -1;
+  }
+
+  c_dir->in_use = 0;
 
-        return result;
+  if (f_closedir(dir) != FR_OK) {
+    errno = EIO;
+    return -1;
+  }
+
+  return 0;
 }
 
-extern "C" void
-rewinddir (DIR *dir)
-{
-        dir->mFirstRead = 1;
+extern "C" int _DEFUN(_stat, (file, st),
+                      const char *file _AND struct stat *st) {
+  char* n2 = strdup2(file);
+  char* f2 = n2;
+  if (strlen(n2) == 1 && n2[0] == '.') { n2[0] = '/'; }
+  if (strlen(n2) > 2 && n2[0] == '.' && n2[1] == '/') n2++;
+
+  memset(st, 0, sizeof(struct stat));
+
+  FILINFO fno;
+  if (f_stat(n2, &fno) == FR_OK) {
+    if (fno.fattrib & AM_DIR) {
+      st->st_mode |= S_IFDIR;
+    } else {
+      st->st_mode |= S_IFREG;
+    }
+    if (fno.fattrib & AM_RDO) {
+      st->st_mode |= S_IREAD;
+    } else {
+      st->st_mode |= S_IREAD | S_IWRITE;
+    }
+
+    st->st_size = fno.fsize;
+    free(f2);
+    return 0;
+  }
+
+  errno = EBADF;
+  free(f2);
+  return -1;
 }
 
-extern "C" int
-closedir (DIR *dir)
-{
-        if (!dir->mOpen)
-        {
-                errno = EBADF;
-                return -1;
-        }
+extern "C" int _DEFUN(_fstat, (fildes, st), int fildes _AND struct stat *st) {
 
-        dir->mOpen = 0;
-        return 0;
+  CircleFile &file = fileTab[fildes];
+  if (!file.in_use) {
+    errno = EBADF;
+    return -1;
+  }
+
+  return _stat(file.fname, st);
+}
+
+extern "C" int _DEFUN(_lseek, (fildes, ptr, dir),
+                      int fildes _AND int ptr _AND int dir) {
+
+  if (fildes < 0 || static_cast<unsigned int>(fildes) >= MAX_OPEN_FILES) {
+    errno = EBADF;
+    return -1;
+  }
+
+  CircleFile &file = fileTab[fildes];
+  if (!file.in_use) {
+    errno = EBADF;
+    return -1;
+  }
+
+  if (file.mode == O_RDONLY) {
+    // Assert FIL has been opened
+    slurp_file(file);
+    if (file.size == 0) {
+       errno = EACCES;
+       return -1;
+    }
+  }
+
+  if (dir == SEEK_SET) {
+    file.position = ptr;
+  } else if (dir == SEEK_CUR) {
+    file.position += ptr;
+  } else if (dir == SEEK_END) {
+    file.position = file.size + ptr;
+  } else {
+    errno = EINVAL;
+    return -1;
+  }
+
+  // Bail
+  assert(file.position >= 0 && file.position <= file.size);
+
+  return file.position;
 }
diff --git a/libgloss/circle/lseek.c b/libgloss/circle/lseek.c
index 0aa89e2..90c8d98 100644
--- a/libgloss/circle/lseek.c
+++ b/libgloss/circle/lseek.c
@@ -10,14 +10,4 @@
 extern int errno;
 #include "warning.h"
 
-int
-_DEFUN (_lseek, (file, ptr, dir),
-        int   file  _AND
-        int   ptr   _AND
-        int   dir)
-{
-  errno = ENOSYS;
-  return -1;
-}
-
-stub_warning(_lseek)
+// Moved to io.cpp
diff --git a/libgloss/circle/stat.c b/libgloss/circle/stat.c
index 7c34637..471c176 100644
--- a/libgloss/circle/stat.c
+++ b/libgloss/circle/stat.c
@@ -12,13 +12,4 @@
 extern int errno;
 #include "warning.h"
 
-int
-_DEFUN (_stat, (file, st),
-        const char  *file _AND
-        struct stat *st)
-{
-  errno = ENOSYS;
-  return -1;
-}
-
-stub_warning(_stat)
+// Moved to io.cpp
diff --git a/newlib/libc/sys/circle/sys/dirent.h b/newlib/libc/sys/circle/sys/dirent.h
index 1f73230..0321778 100644
--- a/newlib/libc/sys/circle/sys/dirent.h
+++ b/newlib/libc/sys/circle/sys/dirent.h
@@ -7,15 +7,44 @@ extern "C" {
 
 #include <sys/types.h>
 
-#include <circle/fs/fsdef.h>
+#include <ff.h>
 
-typedef struct _CIRCLE_DIR DIR;
+#define FS_TITLE_LEN 12
 
 /* Directory entry as returned by readdir */
 struct dirent {
         ino_t  d_ino;
+        unsigned char d_type;
         char   d_name[FS_TITLE_LEN + 1];
 };
+#define _DIRENT_HAVE_D_TYPE
+
+/* File types for `d_type'.  */
+enum
+{
+  DT_UNKNOWN = 0,
+# define DT_UNKNOWN     DT_UNKNOWN
+  DT_FIFO = 1,
+# define DT_FIFO        DT_FIFO
+  DT_CHR = 2,
+# define DT_CHR         DT_CHR
+  DT_DIR = 4,
+# define DT_DIR         DT_DIR
+  DT_BLK = 6,
+# define DT_BLK         DT_BLK
+  DT_REG = 8,
+# define DT_REG         DT_REG
+  DT_LNK = 10,
+# define DT_LNK         DT_LNK
+  DT_SOCK = 12,
+# define DT_SOCK        DT_SOCK
+  DT_WHT = 14
+# define DT_WHT         DT_WHT
+};
+
+/* Convert between stat structure types and directory types.  */
+# define IFTODT(mode)           (((mode) & 0170000) >> 12)
+# define DTTOIF(dirtype)        ((dirtype) << 12)
 
 DIR *opendir(const char *);
 struct dirent *readdir(DIR *);
